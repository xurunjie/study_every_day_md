# C语言程序设计

## 数据类型

### 概述

#### C是有类型的语言

- 在使用前定义，并且
- 确定类型

#### C以后的语言向两个方向发展

- C++/Java更强调类型，对类型的检查更严格
- JavaScript, Python, PHP不看重类型，甚至不需要事先定义

#### 类型安全

- 支持强类型的观点认为明确的类型有助于竟遭发现程序中的简单错误
- 反对强类型的观点认为过于强调类型迫使程序员面对底层， 实现非事务逻辑
- 总的来说， 早期语言强调类型， 面向底层的语言强调类型
- C语言需要类型， 但是对检查的安全检查并不足够

#### C语言的类型

- 整数
  - char
  - short
  - int
  - long
  - long long`(C99类型)`
- 浮点数
  - float
  - double
  - long double`(C99类型)`
- 逻辑
  - bool`(C99类型)`
- 指针
- 自定义类型

#### 类型有何不同

- 类型名称：int， long， double
- 输入输出时的格式化： %d， %ld， %lf
- 所表达的数的范围： char < short < int < float < double
- 内存中所占据的大小： 1个字节到16个字节
- 内存中的表达形式： 二进制数（补码）， 编码

#### sizeof

- 是一个运算符， 给出某个类型或变量在内存中所占据的字节数

  - sizeof(int)
  - sizeof(i)

- ```c
  #include<stdio.h>
  
  int main(void)
  {
      int a;
      a = 6;
      printf("sizeof(int)=%ld\n", sizeof(double));
      printf("sizeof(a)=%ld\n", sizeof(a++));
      return 0;
  }
  
  /*
  ######################
  sizeof(double) = 16
  sizeof(a) = 4
  # sizof是静态的不会真的去做运算
  */
  
  ```

### 整数类型

#### 简介

- char： 1字节(8bit)
- short:  2字节
- int： 取决于编译器（CPU），通常的意义是"1个字"
- long： 取决于编译器（CPU）， 通常的意义是"1个字"
- long long： 8字节
- 小知识：
  - int就是用来表达寄存器的大小的
  - 32位的寄存器大小32bit(4个字节)
  - 64位的寄存器大小64bit(8个字节)
  - cpu -> 总线 -> RAM(内存)
    - 每次通过总线读取32/64bit，一个寄存器中

#### 整数的内部表达

- 计算器内部一切都是二进制
  - 18 ---->  00010010
  - 0   ---->  00000000
  - -18 ---> 10010010

#### 二进制负数

- 1个字节可以表达的数

  - 0000 0000 ----- 1111 1111(0-255)

- 三种方案

  - 仿照十进制， 有一个特殊的标表示负数

  - 取中间的数为0， 如1000 0000表示0，比它小的是负数， 比它大都是正数
  - 补码

#### 补码

- 考虑-1，我们希望-1+1->0, 如何能做到
  - 0 ----> 0000 0000
  - 1 ----> 0000 0001
  - 1111 1111 + 0000 0001 -> 1 0000 0000
- 如果0-1 -》 -1，所以， -1 = 
  - (1)0000 0000 - 0000 0001 -> 1111 1111
  - 1111 1111被当作纯二进制看待时， 是255， 被当作补码看待时是-1
- 同理， 对于-a， 其补码就是0-a, 实际是2^n -a,  n是这种类型的位数

#### 数的范围

- 对于一个字节（8位）， 可以表达的是：
  - 0000 0000 - 1111 1111
- 其中
  - 0000 0000 -> 0
  - 1111 1111 ~ 1000 0000 -> -1 ~ -128
  - 0000 0001 ~ 0111 1111 -> 1 ~ 127

##### 整数的范围

- char: `1字节`: -128 ~ 127
- shor: `2字节`: -32768 ~ 32767
- int: 取决于编译器`(CPU)`, 通常的意义是`一个字`
- long: 4字节
- long long: 8字节

#### unsigned

- 如果一个字面量常数想要表达自己是unsigned, 可以在后面加`u`或者`U`

  - 255U

- 用l或者L表示long(long)

- *unsigned的初衷并非扩展数能表达的范围, 而是为了做纯二进制运算, 主要是为了移位

- ```c
  #include<stdio.h>
  
  
  int main(void)
  {
      char c = 255;
      unsigned char d = 255;
      int i = 255;
      printf("c=%d, i=%d, d = %d\n",c,i,d);
      return 0;
  }
  
  /*
  c=-1, i=255, d = 255
  */
  
  ```

#### 整数越界

- 整数是以纯二进方式进行计算的, 所以:
  - 1111 1111 + 1  -> 1 0000 0000 -> 0
  - 0111 1111 + 1 -> 1000 0000 -> -128
  - 1000 0000 - 1 -> 0111 1111 -> 127

![image-20201205152603858](.\image\image-20201205152603858.png)

![unsigned](E:\study\image\image-20201205153555586.png)

- ```c
  
  
  int main(void)
  {
      char c = 127;
      unsigned char d = 127;
      c = c + 1;
      d = d + 1;
      printf("c = %d d = %d \n", c, d);
      return 0;
  }
  
  /*
  c = -128 d = 128
  ###
  这里要注意正如上图
  unsgined 不在作为负数越界始终为正数, 越界是8个bit 0~255
  ###
  */
  
  ```

#### 整数的输入输出

- 只有两种形式: **int** 或 **long long**
- %d: **int**
- %u: **unsigned**
- %ld: **long long**
- %lu: **unsigned long long**

#### 8进制和16进制

- 一个以**0开始**的数字字面量是**8进制**

- 一个以**0x开始**的数字字面量是16进制

- 输出

  - %o -> 8进制
  - %x -> 16进制

- 8进制和16进制只是如何把数字表达成字符串, 与内部如何表达数字无关

  - 16进制

    - 非常适合表达二进制数据,因为`4位`二进制正好表达是一个16进制位

    - ```c
      //  二进制 0001 0020
      转化
      // 16进制     1   2
          
      /*
      	16进制的2位正好表达一个字节 16^2 = 256 正好表达一个字节
      */    
      ```

  - 8进制
    - 一个数字正好表达`3位`二进制
    - 因为早期的计算机的字长是12的倍数,而非8

- 需要注意

  - 计算机内部永远只是二进制
  - **8进制和16进制,编译器编译的时候给转的**

  ```c
  #include<stdio.h>
  
  
  int main(void)
  {
      char c = 012;
      int i = 0x12;
      printf("c = %d i = %d\n", c, i);
      return 0;
  
  }
  
  /*
  c = 10 i = 18
  */
  ```

#### 选择整数类型

- 为什么整数要有那么多种
  - 为了准确表达内存, 做底层程序的需要
- 没有特殊需要, 就选择int
  - 现在的CPU的字长普遍是32位或者64位, 一次内存读写就是一个int, 一次计算也是一个int, 选择更短的类型是不会更快, 甚至可能更慢
  - **现代的编译器一般是设计内存对齐, 所以更短的类型实际在内存中有可能也占据一个`int`的大小(虽然不sizeof告诉你更小)**
- unsigned与否只是输出的不同, 内部计算是一样的

### 浮点类型

|  类型  | 字长 |                    范围                    | 有效数字 | scanf | printf |
| :----: | :--: | :----------------------------------------: | :------: | :---: | :----: |
| float  |  32  | +-(1.20x10^-38 ~ 3.40x10^38), 0, +-inf,nan |    7     |  %f   | %f, %e |
| double |  64  | +-(2.2x10^-308 ~ 1.79x10^308),0,+-inf,nan  |    15    |  %lf  | %f,%e  |

#### 输出精度

- 在%和f之间加上**.n**可以指定输出小数点后几位, 这样的输出是4舍五入的

- ```c
  #include<stdio.h>
  
  int main(void)
  {
      printf("%.3f\n", -0.0049);
      printf("%.30f\n", -0.0049);
      printf("%.3f\n",-0.00049);
      return 0;
  }
  /*
  -0.005
  -0.004899999999999999841793218991
  -0.005
  # 四舍五入
  */
  ```

#### 超过范围的浮点数

- **printf**输出**inf**表示超过范围的浮点数: +∞

- **printf**输出**nan**表示不存在的浮点数

- ```c
  #include<stdio.h>
  
  
  int main(void)
  {
      printf("%f\n", 12.0/0.0);
      printf("%f\n", -12.0/0.0);
      printf("%f\n",0.0/0.0);
      return 0;
  }
  
  /*
  inf
  -inf
  -nan
  
  ##
  inf 无穷大
  +-	正负
  nan	不存在的数
  ##
  */
  ```

#### 浮点运算的精度

- 带小数点的字面量是**double**而非**float**
- **float**需要用**f**或**F**后缀来表明身份

- ```c
  #include<stdio.h>
  
  
  int main(void)
  {
      float a,b,c;
      a = 1.345f;
      b = 1.123f;
      c = a + b;
      if ( c == 2.468)
          printf("相等\n");
      else
          printf("不相等\n");
      return 0;
  }
  
  /*
  不相等
  ###
  1.345f 字面量是float  7位
  2.468 字面量是double 15位
  精度不同
  ###
  */
  ```

#### 浮点数的内部表达

![image-20201205173408175](.\image\image-20201205173408175.png)

- 浮点数在计算时是由专用的硬件部件实现的
- 计算**double**和**float**所用的部件是一样的

#### 选择浮点类型

- 如果没有特殊需要,只使用**double**
- 现代**CPU**能直接对**double**做硬件运算,性能不会比**float**差,在**64**位的机器上,数据存储的速度也不比**float**慢

### 逻辑类型

#### bool

- **#include<stdbool.h>**

- 之后就可以用bool和true、false

- ```c
  #include<stdio.h>
  #include<stdbool.h>
  
  
  int main(void)
  {
      bool b = 6 > 5;
      bool t = true;
      t = 2;
      printf("d = %d t = %d\n", b, t);
      return 0;
  }
  
  
  /*
  d = 1 t =1
  ###
  bool 实际上是1或者0 true -> 1 false -> 0
  ###
  */
  ```

#### 逻辑运算

- 逻辑运算是对逻辑量进行的运算, 结果只有0或1
- 逻辑量是关系运算或逻辑运算的结果

| 运算符 |  描述  |  示例  |                             结果                             |
| :----: | :----: | :----: | :----------------------------------------------------------: |
|   !    | 逻辑非 |   !a   | 如果**a是true**结果就是**false**<br />如果**a是false**结果就是**true** |
|   &&   | 逻辑与 | a && b |            true && true 结果是true<br />否则false            |
|  \|\|  | 逻辑或 | a\|\|b | 如果a和b有一个true,结果为true<br />两个都是false,结果为false |

#### TRY

- 如果要表达数学中的区间, 如: **x∈(4,6)或x∈[4,6]**,应该如何写c的表达式
  - 错误
    - 示例
      - 4 < x <6
    - 错误原因
      - 不是C能正确计算的式子
      - 因为 4 < x 的结果是一个逻辑值(0或1)
  - 正确
    - 示例
      - x > 4 && x < 6
- 如何判断一个字符c是否是大写字母?
  - c >= 'A' && c <= 'Z'
    - c ∈ ['A', 'Z']
- 理解
  - age > 20 && age < 30
    - age ∈ (20, 30)
  - index < 0 || index > 99
    - index ∈ (-∞, 0) || index ∈ (99, +∞)
  - !age < 20
    - 1 < 20 -> true

#### 优先级的陷阱

![image-20201205215620125](.\image\image-20201205215620125.png)

#### 短路

- 逻辑运算是自左向右进行的, 如果左边的结果,已经能决定结果了,就不会做右边的计算
  - a == 6 && b == 1
  - a == 6 && b += 1
- 对于&&, 左边是false时就不做左边了
- 对于||,左边是true时就不做右边了
- 解决核心
  - 不要把赋值组合进表达式!

### 类型转换和条件运算

#### 条件运算符

- count = (count > 20)?count - 10:count+10;

- 条件、条件满足时的值和条件不满足时的值

- 相当于如下

  - ```c
    if (count > 20)
        	count = count - 10;
    else
        	count = count + 10;
    ```

#### 优先级

- 条件运算符的优先级高于赋值运算符,但是低于其他运算符
  - m < n? x : a + 5
  - a ++ >= 1 &&  b-- > 2 ? a : b
  - x = 3 * a > 5? 5 : 20

#### 嵌套条件表达式

- count = (count > 20) ? (count < 50)? count - 10: count -5? count + 10 : count + 5;
- 条件运算符是自右向左结合的
  - w < x ? x + w : x < y ? x : y
- 避免复杂方式
  - 不要使用嵌套的条件表达式

#### 逗号运算

- 逗号用来连接两个表达式, 并以其右边的表达式的值作为他的结果

  - 逗号的优先级是所有的运算符中最低的,
  -  所以它两边的表达式会先计算;  
  - 逗号的组合关系是自左向右, 
  - 所以左边的表达式会先计算,
  -  而右边的表达式的值就留下来作为逗号运算的结果

- ```c
  #include<stdio.h>
  
  
  int main(void)
  {
      int i;
      i = 3 + 4, 5 + 6;
      printf("%d\n", i);
      i = (3 + 4, 5 + 6);
      printf("%d\n", i);
      return 0;
  }
  
  /*
  7
  11
  ###
  第一个 i = 3 + 4 = 7	
  第二个 i = 5 + 6 = 11 (右括号括号先算)
  ","号的优先级是最低的
  ###
  */
  
  ```

### 指针和字符串

#### 指针

##### 运用场景一

- 交换两个变量的值

- ```c
  #include<stdio.h>
  
  void swap(int *pa, int *pb);
  
  int main(void)
  {
      int a = 5;
      int b = 6;
      swap(&a, &b);
      printf("a = %d b = %d \n", a, b);
      return 0;
  }
  
  void swap(int *pa, int *pb)
  {
      int t = *pa;
      *pa = *pb;
      *pb = t;
  }
  
  /*
  a = 6 b = 5
  */
  ```

##### 应用场景二

- 函数返回多个值, 某些值就只能通过指针返回

  - 传入的参数实际上是需要保存待会的结果的变量

- ```c
  
  #include<stdio.h>
  
  void minmax(int a[], int len, int *max, int *min);
  
  int main(void)
  {
      int a[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18};
      int min,max;
      minmax(a, sizeof(a)/sizeof(a[0]), &min, &max);
      printf("min = %d, max = %d \n", min, max);
      return 0;
  }
  
  void minmax(int a[], int len, int *min, int *max)
  {
      int i;
      *min = *max = a[0];
      for (i=1;i<len;i++){
          if(a[i] < *min){
              *min = a[i];
          }
          if(a[i] > *max){
              *max = a[i];
          }
      }
  }
  
  /*
  "min = 1, max = 18 
  */
  ```

##### 应用场景二B

- 函数返回运算的状态, 结果通过指正返回

- 常用的套路是让函数返回特殊不属于有效范围内的值来表示出错;

  - **-1 或 0(在文件操作会看到大量的例子)**

- 但是当任何数值都是有效的可能结果时, 就得分开返回了

- ```c
  #include<stdio.h>
  
  int devide(int a, int b, int *result);
  
  int main(void)
  {
      int a, b, c;
      a = 5;
      // b = 0;
      b = 3;
      if (devide(a, b, &c)){
          printf("%d/%d=%d\n", a, b, c);
      }
      return 0;
  }
  
  int devide(int a, int b, int *result)
  {
      int ret = 1;
      if( !b ) ret = 0;
      else *result = a/b;
      return ret;
  }
  
  
  /*
  5/3=1
  ###
  ret 返回状态 1 代表成功 0 代表失败
  ###
  */
  ```

  - 后续的语言(c++,java)采用了一场极致来解决这问题
  
  ##### 指针最常见的错误
  
  - 定义了指针变量, 还没有指向任何变量就开始使用指针







