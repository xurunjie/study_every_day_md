# 数据结构和算法

## 简介

### 数据结构和算法的重要性

> - 算法是程序的灵魂, 优秀的程序可以再海量数据计算时, 依然保持高速计算
> - 一般来讲程序会使用内存计算框架(比如`Spark`)和缓存技术(比如`Redis等`)来优化程序,再深度的思考一下, 这些`计算框架`和`缓存技术, 他的核心功能是哪个部分?`
> - 拿实际工作经历来说, 在Unix开发服务器程序, 功能是要支持上千万人同时在线, 在上线前, 做内测, 一切OK, 可上线后, 服务器就支持布置了, 公司的CTO对代码进行优化, 再次上线, 坚入磐石, 你就能感受道程序是有灵魂的, 就是算法
> - 目前程序员面试的门槛越来越高, 很多一些IT公司, 都会有数据结构和算法面试题
> - 如果你不想永远都是代码工人, 那就花时间来研究下数据结构和算法

### 数据结构和算法的介绍

> - 数据data结构(`structure`)是一门研究组织`数据`方式的学科, 有了编程语言也就有了数据结构, 学好数据结构可以编写出更有效率的代码
> - 学好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决
> - 程序 = `数据机构` + 算法 

## 数据结构

### 线性结构

- 线性结构为`最常用的数据结构`,其特点是数据元素之间存在一对一的线性关系
- 线性结构有两种不同的存储结构, 既`顺序存储结构`和`链表存储结构`,顺序存储的线性表为`顺序表`,顺序表中的存储元素是连续的
- `链式存储`的线性表成为链表, 链表中的存储元素不一定是连续的, 元素节点中存放数据元素以及相邻元素的地址信息
- 线性结构常见的有:`数组、队列、链表和栈`

### 非线性数组

- 非线性数据包括:`二维数组, 多维数组, 广义表, 树结构, 图结构`


### 队列

- `简介`
  - 队列是一个有序列表,可以用`数组`或者`链表`来实现
  - 遵循`先入先出`的原则. 既: 先存入队列的数据, 要先取出. 后存入的要后取出

- `示意图`

  - ![](./images/队列.png)

- `数组模拟队列`

  - ```markdown
    - 队列本身是有序列表, 若使用数组的结构来存储队列的数据, 其中队列数组的声明如上图, 其中maxSize是该队列的最大容量
    - 因为队列的输出、输入是分别从前后端来处理, 因此需要两个变量`front`和`rear`分辨记录队列前后端的下标,`front`会随着数据输出而变化,而`rear`则是随着数据输入而变化,如上图所示
    ```

- `思路分析`

  - 当我们将数据存入队列时成为`addQueue`, `addQueue`的处理需要两个步骤: `思路分析`
    - 将尾指针网后移动: rear + 1,当front == rear [空]
    - 若尾指针`rear`小于队列的最大下标`maxSize-1`,则将数据存入`rear`所指的数组元素中,否则无法存入数据. `rear==maxSize-1`[队列满]

- `问题分析并优化`

  - 目前数组使用一次就不能用, 没有达到复用的效果
  - 将这个数组使用算法, 改进成一个环形的队列 取模: %

### 环形队列

- `思路如下`
  - `front`变量的含义做一个调整: front执行指向队列的第一个元素, 也就是说arr[front]就是队列的第一个元素 `front的初始值=0`
  - `rear`变量的含义做一个调整: `rear`指向队列的最后一个元素的后一个位置. `rear的初始值=0`
  - 当队列满时, 条件是 `(rear + 1) % maxSize= front`
  - 当队列为空的条件, `rear==front`空

### 单链表

- `介绍`
  - 链表是有序的列表,但是他在内存中是存储如下
- `图示`
  - ![](./images/链表.png)
- `图示总结`
  - 链表是以节点的方式存储的
  - 每个节点包含`data`域, `next`域:指向下一个节点
  - 链表的各个节点不一定是连续存储的
  - 链表分带头节点的链表和没有带头节点的链表吗, 根据实际的需求来确定
- `单链表`
  - 示例
  - ![](./images/带头节点的单链表.png)
  - 实现细节
    - 先创建一个`head`头节点，作用就是表示单链表的头
    - 后面我们每天假一个节点，就直接加入到链表的最后
    - 遍历：
      - 通过一个辅助遍历，帮助遍历整个链表

### 双向链表

- `与单向链表的区别`
  - 单向链表, 查找的方向只能是一个方向,而双向链表可以向前或者向后查找
  - 单向链表不能自我删除, 需要靠辅助接点, 而双向链表,则可以`自我删除`,所以前面我们单链表删除时接点,总是找到`temp`,`temp`时待删除接点的前一个节点
- `图示`
  - ![](./images/双向链表.png)
- `双向链表的遍历, 添加, 修改, 删除的思路`
  - 遍历从前或者后都可以
  - 添加
    - 先找到双向链表的最后一个节点`temp`
    - `temp.next = node`
    - `node.pre = temp`
  - 修改
  - 删除
    - 因为是双向链表,因此,我们可以实现自我删除某个节点
    - 直接找到要删除的节点,比如 `temp`
    - `temp.pre.next=temp.next`实现删除
    - `temp.next.pre = temp.pre`

### 单向环形

- `Josephu(约瑟夫问题)`
  - 设置编号为`1,2,...n`的n个人围坐一圈,约定编号为`k(1<=k<=n)`的人从1开始计数,数到m的那个人出列,阿德下一位又从1开始报数,数到m的那个人又出列,依次类推,知道所有人出列位置,`由次产生一个出队编号的序列`
- `图示`
  - ![](./images/单向环形链表.png)
- `思路`
  - 1. 先创建第一个节点, 让`first`指向该节点, 并形成环形
    2. 后面当我们没创建一个新节点, 就把该节点, 加入到已有的环形链表中即可
  - `遍历环形链表`
    - 1. 先考虑条件需要起始的位置 `startId`,步数`step`, 总数`count`
      2. 获取结束链表最后一个的数据的指针`lastTemp`
      3. 移动到起始`startId`所在的位置
      4. 判断当`lastTemp==startTemp`,取出结束,其中有置换对接的过程

### 栈(stack)

- `简介`
  - 栈是一个`先入后出`的有序列表
  - `栈`是限制线性表中元素的插入和删除`只能在线性表的同一端`进行的一中特殊的线性表, 允许插入和删除的一端,为变化的一端,称为`栈顶`,另一端为固定的一端, 称为`栈底`
  - 根据栈的定义可知,最先放入栈中元素在栈底,最后放入的元素在栈顶,二删除元素刚好相反,最后放入的元素最先删除没最先放入的元素最后删除
- `出栈和入栈的概念`
  - ![](./images/出栈和入栈.png)
- `应用场景`
  - 1. 子程序的调用: 在跳往子程序前,回显将下个指令的地址存到堆栈中,知道子程序执行完后再地址只取出,一回到原先的程序中
    2. 处理递归调用: 和子程序的调用类似, 只是出了储存下一个指令的地址外,也将参数、区域变量等数据存入堆栈中
    3. 表达式的转化`[中缀表达式转后缀表达式]`与求值问题
    4. 二叉树的遍历
    5. 图形的深度优先搜索算法
- `实现栈的思路分析`
  - 1. 使用数组来模拟栈
    2. 定义一个`top`来表示栈顶, 初始化为-1
    3. 入栈的操作,当有数据加入到栈时, top++,stack[top]=data;
    4. 出栈的操作, int value = stack[top];top--;return value

### 递归

- `迷宫回溯问题`
  - ![](./images/小老鼠找家.png)
- `图解`
  - ![](./images/递归栈分析.png)
- `递归需要遵守的规则 ---> 如上述图示`
  - 执行一个方法是,就创建一个新的受保护的`独立空间(栈空间)`
  - 方法的`局部变量是独立`的,不会互相影响,比如n变量
  - 如果方法中使用的`是引用类型的变量`(比如数组),就会共享改引用类型的数据
  - 递归`必须向退出递归的条件`逼近,否则就是无限循环
  - 当一个方法执行完毕,或者`遇到return就会返回`,遵守谁调用,就将结果返回给谁,同事当方法执行完毕或者返回时,该方法也执行完毕

## 排序算法

- **排序的分类**:
  - 内部排序: 指将需要处理的所有数据都加在到内部存储器中进行排序
  - 外部排序: 数据量过大,无法全部加载到内存中,需要借助外部存储进行排序
- **图解**
  
  - ![](./images/排序.png)
- **算法的时间复杂度**
  - 事后统计法
    
    - 这种方法可行, 但是有两个问题: 一是要相对设计的算法的运行性能进行评测,需要实际运行该程序; 二是所得事件的统计量依赖于计算机的硬件、软件等环境因素,`这种方式,要在对同一台计算机的相同状态下运行,才能比较那种算法速度较快`
    
  - 事后估算的方法
    
    - 通过分析某种算法的时间复杂度来判断哪种算法更优
    
  - 图解
    
    - ![](./images/时间复杂度.png)
    
  - **`时间复杂度主要概念`**
    - 一般情况下,算法中的基本操作语句的重复执行次数是问题规模` n`的某个函数,用 **T(n)**表示,若有某个辅助函数**f(n)**,是的当 `n`趋近与无穷大时, `T(n)/f(n)`的极限值为不等于零的常熟,则称 `f(n)`是 `T(n)`的同数量级函数, 记做 **T(n) = O(f(n))**,称为 **O(f(n))**为算法的渐进时间复杂度,简称**时间复杂度**
    -  **T(n)**不同, 但时间复杂度可能相同, 如果: **T(n)=n^2 + 7n + 6** 与 **T(n) = 3n^2 + 2n + 2**它们的 T(n)不同, 但时间复杂度相同,都是 **T(n)**
    - 计算时间复杂度的方法
      - 用常熟 1 代替运行时间中的所有假发常熟
      - 修改后的运行函数中,只保留最高阶项
      - 取出最高阶项的系数
    
  - 图解
    - ![](./images/指数阶.png)

    ### 冒泡排序

    - `基本思想`
      - 通过对待排序序列从前向后(从下表比较小的元素开始),依次比较相邻元素的值,若发现逆序则交换,使值越大的元素逐渐从前移向后部,就像水底下的气泡一样逐渐向上冒
      - 因为排序的过程中,个元素不断接近自己的位置,如果一趟比较下来没有进行过交换,就说明序列有序,因此要在排序过程中设置一个标志 flag 判断元素是否进行过交换, 从而减少不必要的比较
    - `规则`
      - 一共进行数组大小`-1`次大的排序
      - 每一趟排序的次数在逐渐地减少
      - 如果我们发现在某趟排序中没有发生一次交换,可以提前结束冒泡排序

    

 