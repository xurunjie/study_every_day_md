# 数据结构和算法

## 简介

### 数据结构和算法的重要性

> - 算法是程序的灵魂, 优秀的程序可以再海量数据计算时, 依然保持高速计算
> - 一般来讲程序会使用内存计算框架(比如`Spark`)和缓存技术(比如`Redis等`)来优化程序,再深度的思考一下, 这些`计算框架`和`缓存技术, 他的核心功能是哪个部分?`
> - 拿实际工作经历来说, 在Unix开发服务器程序, 功能是要支持上千万人同时在线, 在上线前, 做内测, 一切OK, 可上线后, 服务器就支持布置了, 公司的CTO对代码进行优化, 再次上线, 坚入磐石, 你就能感受道程序是有灵魂的, 就是算法
> - 目前程序员面试的门槛越来越高, 很多一些IT公司, 都会有数据结构和算法面试题
> - 如果你不想永远都是代码工人, 那就花时间来研究下数据结构和算法

### 数据结构和算法的介绍

> - 数据data结构(`structure`)是一门研究组织`数据`方式的学科, 有了编程语言也就有了数据结构, 学好数据结构可以编写出更有效率的代码
> - 学好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决
> - 程序 = `数据机构` + 算法 

## 数据结构

### 线性结构

- 线性结构为`最常用的数据结构`,其特点是数据元素之间存在一对一的线性关系
- 线性结构有两种不同的存储结构, 既`顺序存储结构`和`链表存储结构`,顺序存储的线性表为`顺序表`,顺序表中的存储元素是连续的
- `链式存储`的线性表成为链表, 链表中的存储元素不一定是连续的, 元素节点中存放数据元素以及相邻元素的地址信息
- 线性结构常见的有:`数组、队列、链表和栈`

### 非线性数组

- 非线性数据包括:`二维数组, 多维数组, 广义表, 树结构, 图结构`


### 队列

- `简介`
  - 队列是一个有序列表,可以用`数组`或者`链表`来实现
  - 遵循`先入先出`的原则. 既: 先存入队列的数据, 要先取出. 后存入的要后取出

- `示意图`

  - ![](./images/队列.png)

- `数组模拟队列`

  - ```markdown
    - 队列本身是有序列表, 若使用数组的结构来存储队列的数据, 其中队列数组的声明如上图, 其中maxSize是该队列的最大容量
    - 因为队列的输出、输入是分别从前后端来处理, 因此需要两个变量`front`和`rear`分辨记录队列前后端的下标,`front`会随着数据输出而变化,而`rear`则是随着数据输入而变化,如上图所示
    ```

- `思路分析`

  - 当我们将数据存入队列时成为`addQueue`, `addQueue`的处理需要两个步骤: `思路分析`
    - 将尾指针网后移动: rear + 1,当front == rear [空]
    - 若尾指针`rear`小于队列的最大下标`maxSize-1`,则将数据存入`rear`所指的数组元素中,否则无法存入数据. `rear==maxSize-1`[队列满]

- `问题分析并优化`

  - 目前数组使用一次就不能用, 没有达到复用的效果
  - 将这个数组使用算法, 改进成一个环形的队列 取模: %

### 环形队列

- `思路如下`
  - `front`变量的含义做一个调整: front执行指向队列的第一个元素, 也就是说arr[front]就是队列的第一个元素 `front的初始值=0`
  - `rear`变量的含义做一个调整: `rear`指向队列的最后一个元素的后一个位置. `rear的初始值=0`
  - 当队列满时, 条件是 `(rear + 1) % maxSize= front`
  - 当队列为空的条件, `rear==front`空

### 单链表

- `介绍`
  - 链表是有序的列表,但是他在内存中是存储如下
- `图示`
  - ![](./images/链表.png)
- `图示总结`
  - 链表是以节点的方式存储的
  - 每个节点包含`data`域, `next`域:指向下一个节点
  - 链表的各个节点不一定是连续存储的
  - 链表分带头节点的链表和没有带头节点的链表吗, 根据实际的需求来确定
- `单链表`
  - 示例
  - ![](./images/带头节点的单链表.png)
  - 实现细节
    - 先创建一个`head`头节点，作用就是表示单链表的头
    - 后面我们每天假一个节点，就直接加入到链表的最后
    - 遍历：
      - 通过一个辅助遍历，帮助遍历整个链表

### 双向链表

- `与单向链表的区别`
  - 单向链表, 查找的方向只能是一个方向,而双向链表可以向前或者向后查找
  - 单向链表不能自我删除, 需要靠辅助接点, 而双向链表,则可以`自我删除`,所以前面我们单链表删除时接点,总是找到`temp`,`temp`时待删除接点的前一个节点
- `图示`
  - ![](./images/双向链表.png)
- `双向链表的遍历, 添加, 修改, 删除的思路`
  - 遍历从前或者后都可以
  - 添加
    - 先找到双向链表的最后一个节点`temp`
    - `temp.next = node`
    - `node.pre = temp`
  - 修改
  - 删除
    - 因为是双向链表,因此,我们可以实现自我删除某个节点
    - 直接找到要删除的节点,比如 `temp`
    - `temp.pre.next=temp.next`实现删除
    - `temp.next.pre = temp.pre`

### 单向环形

- `Josephu(约瑟夫问题)`
  - 设置编号为`1,2,...n`的n个人围坐一圈,约定编号为`k(1<=k<=n)`的人从1开始计数,数到m的那个人出列,阿德下一位又从1开始报数,数到m的那个人又出列,依次类推,知道所有人出列位置,`由次产生一个出队编号的序列`
- `图示`
  - ![](./images/单向环形链表.png)
- `思路`
  - 1. 先创建第一个节点, 让`first`指向该节点, 并形成环形
    2. 后面当我们没创建一个新节点, 就把该节点, 加入到已有的环形链表中即可
  - `遍历环形链表`
    - ​